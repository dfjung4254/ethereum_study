## About BlockChain and Ethereum

1. BlockChain
  - 전세계적으로 공유되어 트랜잭션이 일어나는 데이터베이스
  - 네트워크에 참여하면 누구나 데이터베이스를 살펴볼 수 있다.
  - 데이터베이스의 어떤 것을 변경하려면 트랜잭션을 생성해야하고, 모두가 동의해야만 한다.


2. Transaction
  - 만드려는 변화가 모두 되었거나, 모두 안되었거나, 변화의 최소단위 설정
  - Ex:) 계좌 송금은 1. 보내는 계좌의 금액(-) 2. 받는 계좌의 금액(+) 의 2가지 절차가 동시에 일어났거나 또는 일어나지 않거나를 보장해야 한다.
  - 항상 만든 사용자에 의해 암호화 됨, 항상 계좌의 키를 소유한 사용자만 권한을 가지는 것을 보장.
  - 한 계정에서 다른 계정으로 보내지는 메시지(binary data, Ether amount 등)
  - 트랜잭션 대상이 모드를 포함하고 있으면 코드는 실행되고, 페이로드는 입력 데이터로 제공 됨.


3. Block
  - 트랜잭션의 순서는 정의한 대로, 블록에 합쳐지며, 모든 노드에 전파된다.
  - 두 트랜잭션이 충돌한 경우 두 번째가 되는 트랜잭션은 거절되며 블록의 일부가 되지 않는다.
  - 블록은 시간에 따라 선형의 순서를 가지며 체인형태로 계속 연결되어 생성된다.(Ethereum 17초마다 생성)
  - 채굴자에 의해 블록의 포함여부, 순서가 바뀔 수 있음.


4. Ethereum Virtual Machine(EVM)
  - 이더리움의 스마트 컨트랙트를 위한 Runtime Environment


5. Account
  - 외부 계정 : 공개키, 비밀키 쌍으로 동작
    - 주소 : 공개키에 의해 정해짐
  - 컨트랙트 계정 : 계정과 함께 저장도니 코드에 의해 동작
    - 주소 : 생성되는 시점에 정해짐
  - 모든 계정은 key-value 쌍으로 매핑된 스토리지 보유, 트랜잭션으로 바뀔 수 있는 Ether 잔액을 소유.


6. Gas
  - 트랜잭션 발생 시 일정량의 가스가 사용 된다.
  - 트랜잭션 실행에 필요한 작업의 양을 제한하는 목적
  - 가스 가격은 트랜잭션 만든 사용자가 정함.
  - 최대 가스 가격 * 가스 양 을 트랜잭션 비용으로 지불.


7. Storage, Memory, Stack
  - EVM 에는 Storage, Memory, Stack 3가지 영역 존재.
  - Storage
    - 256비트 Key-Value 형식 저장소
    - 컨트랙트 내 스토리지를 탐색하는 것은 불가능, R/W 비용 ↑
    - 컨트랙트가 소유하지 않은 스토리지는 R/W 불가능
  - Memory
    - 각 Message Call 에 대해 새로 초기화된 인스턴스 보유
    - 선형이며 Byte Level 로 다뤄짐
    - 이전에 변경되지 않은 메모리 워드 영역에 액세스 할 때 메모리는 256비트 워드 영역으로 확장, 확장되는 시점에 가스 지불
  - Stack
    - EVM 은 레지스터머신이 아니라 스택 머신
    - 모든 연산은 스택 공간에서 처리 됨.
    - 스택은 최상단 2개의 스택을 가져와 연산 결과를 푸시하며, 스택 요소를 Storage, Memory 에 옮기는 것도 가능
    - 스택 상단요소를 제거하지 않고 임의의 하위 스택요소 접근은 불가능


8. Instruction Set
  - EVM 명령어들은 최소로 구성, 모든 명령어는 기본 데이터 타입, 256비트 단어 또는 메모리 조각을 기반으로 동작


9. Message Call
  - 메시지 콜을 통해 컨트랙트는 다른 컨트랙트를 호출하거나 컨트랙트가 아닌 계정으로 Ether를 송금할 수 있다.
  - 송신자, 수신자, Data Payload, Ether, Gas, Return Value 등을 가지고 있어 트랜잭션과 유사
  - 컨트랙트는 내부 메시지 호출과 함께 보내고 남길 가스량을 정할 수 있음.
  - 호출된 컨트랙트는 비워진 메모리 인스턴스와 호출 데이터라는 격리된 공간의 호출 페이로드 접근 권한을 가짐, 실행이 완료되면 호출자에 의해 이미 할당된 메모리 영역 안에 저장될 데이터를 리턴받을 수 있음. 동기식으로 호출이 진행됨.


10. Delegate Call
  - 메시지 콜의 다양한 변형 중 하나.
  - 컨트랙트가 실행 중 다양한 주소의 코드를 동적으로 불러옴.
  - Storage, 현재 주소, 잔액은 여전히 호출하는 컨트랙트를 참조하지만 코드는 호출된 주소에서 가져옴.
  - Solidity에서 복잡한 데이터 구조 표현이 가능한 컨트랙트의 스토리지에 적용 가능한 재사용 가능한 코드, "라이브러리"의 구현을 가능하도록 함.


11. Log
  - 블록 레벨까지의 모든 절차를 매핑하여 특별히 인덱싱된 데이터 구조 데이터를 저장하는 것
  - Solidity 에서 이벤트를 구현하기 위해 사용됨.

  